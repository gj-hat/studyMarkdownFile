# RIP动态路由协议

## 引入

上一篇我们讲了，数据再网络中是怎么传输的。举了一个比较贴切的例子是“快递的收发过程”，而快递的收发和转发的路径就可以近似的称为是——路由。
这是一个简单的路由模型，为什么说简单呢？因为我们假设全国的所有的路径城市都是相通的，而且每一条路都十分宽敞不存在拥堵，所以近乎来说；从寄件地址到收件地址之间的路径是唯一的。
不妨往深考虑一下，我们假设从北京到西安的直连路给断了，那么问题就复杂了，因为我们现在就几乎有无数种路线了，又或者就停止发送快递即就是丢包；因为计算机是比较“笨”的，他除了直连路由和静态路由之外他是不会学习路径的。
这个时候就需要动态路由协议的帮忙了，今天讲述的是动态路由RIP的基本路径选择原理。

## RIP简介

RIP（Routing information Protocol，路由信息协议）是应用较早、使用较普遍的内部网关协议），适用于小型同类网络的一个自治系统（AS）内的路由信息的传递。RIP协议是基于距离矢量算法的。它使用“跳数”，即metric来衡量到达目标地址的路由距离。文档见RFC1058、RFC1723。它是一个用于路由器和主机间交换路由信息的距离向量协议。

至于上面所说到的“内部网关协议”，我们可以这样理解。由于历史的原因，当前的 INTERNET 网被组成一系列的自治系统，各自治系统通过一个核心路由器连到主干网上。而一个自治系统往往对应一个组织实体（比如一个公司或大学）内部的网络与路由器集合。每个自治系统都有自己的路由技术，对不同的自治系统路由技术是不相同的。用于自治系统间接口上的路由协议称为“外部网关协议”，简称EGP （Exterior Gateway Protocol）；而用于自治系统内部的路由协议称为“内部网关协议”，简称 IGP。内部网关与外部网关协议不同，外部路由协议只有一个，而内部路由器协议则是一族。各内部路由器协议的区别在于**距离制式（distance metric, 即距离度量标准）不同，和路由刷新算法不同**。
RIP协议被设计用于使用同种技术的中型网络，因此适应于大多数的校园网和使用速率变化不是很大的连续线的地区性网络。对于更复杂的环境，一般不使用RIP协议。

rip分为ripv1和ripv2两个版本。
ripv1是有类别路由协议，报文不包含掩码信息，不支持VLSM。RIPV1只支持广播形式发送。
ripv2支持VLSM,支持明文和md5认证

## RIP工作原理

路由器的关键作用是用于网络的互连，每个路由器与两个以上的实际网络相连，负责在这些网络之间转发数据报。在讨论 IP 进行选路和对报文进行转发时，我们总是假设路由器包含了正确的路由，而且路由器可以利用 ICMP 重定向机制来要求与之相连的主机更改路由。但在实际情况下，IP 进行选路之前必须先通过某种方法获取正确的路由表。在小型的、变化缓慢的互连网络中，管理者可以用手工方式来建立和更改路由表（静态路由）。而在大型的、迅速变化的环境下，人工更新的办法慢得不能接受。这就需要自动更新路由表的方法，即所谓的动态路由协议，RIP协议是其中最简单的一种。

在路由实现时，RIP作为一个系统长驻进程（daemon）而存在于路由器中，负责从网络系统的其它路由器接收路由信息，从而对本地IP层路由表作动态的维护，保证IP层发送报文时选择正确的路由。同时负责广播本路由器的路由信息，通知相邻路由器作相应的修改。RIP协议处于UDP协议的上层，RIP所接收的路由信息都封装在UDP协议的数据报中，RIP在520号UDP端口上接收来自远程路由器的路由修改信息，并对本地的路由表做相应的修改，同时通知其它路由器。通过这种方式，达到全局路由的有效。

RIP路由协议用“更新（UNPDATES）”和“请求（REQUESTS）”这两种分组来传输信息的。每个具有RIP协议功能的路由器每隔30秒用UDP：520端口给与之直接相连的机器广播更新信息。更新信息反映了该路由器所有的路由选择信息数据库。路由选择信息数据库的每个条目由“局域网上能达到的IP地址”和“与该网络的距离”两部分组成。请求信息用于寻找网络上能发出RIP报文的其他设备。

## rip默认设置

1. Cost值：度量值大于等于16表示该路由不可达
2. Update定时器：邻居间路由更新的发送时间默认30s（每隔30s一广播形式发送自己的rip路由表）
3. Timeout定时器：默认180秒没有收到的回复路由信息会将cost设置为无穷大（16）并在ip路由表中撤销
4. rip端口520采用udp传输

## RIP路由表

**rip路由表大致如下：**
[![img](https://s1.ax1x.com/2018/12/17/F0ulyF.png)](https://s1.ax1x.com/2018/12/17/F0ulyF.png)

```
display rip 1 route
```

第一列：目标地址
第二列：下一跳地址
第三列：cost开销值

**rip协议的距离标准是距离矢量所以在乎的主要的目标地址和下一跳**

### 跳数

RIP用“路程段数”（即“跳数”）作为网络距离的尺度。每个路由器在给相邻路由器发出路由信息时，都会给每个路径加上内部距离。在如图中，路由器1直接和网络192.168.1.0/24相连。当它向路由器2通告网络192.168.1.0/24的路径时，它把跳数增加1。

## rip的更新机制

任何距离向量路由选择协议（如RIP）都有一个问题，路由器不知道网络的全局情况，路由器必须依靠相邻路由器来获取网络的可达信息。由于路由选择更新信息在网络上传播慢，距离向量路由选择算法有一个慢收敛问题，这个问题将导致不一致性产生。RIP协议使用以下机制减少因网络上的不一致带来的路由选择环路的可能性。

对于rip动态路由协议，当网络拓扑发生改变后的Update时间后；运行rip协议的路由器会将所有的网络发布给rip区域内的所有路由器并将cost值+1；

**下面来实战看看运行rip的网络拓扑：**

> 同一设备不同端口网段不同，同一链路须在同一网段

[![img](https://s1.ax1x.com/2018/12/19/FBzfUg.png)](https://s1.ax1x.com/2018/12/19/FBzfUg.png)

这是一个简单的拓扑图。

配置如下：

```
int g 0/1 
ip add 192.0.1.1 24
int g 0/2
ip add 192.0.2.1 24
quit
int loopback 0
ip add 1.1.1.1 32
```



其他路由器配置类似；
查看路由表

```
dis ip-route
```



[![img](https://s1.ax1x.com/2018/12/19/FBzh5Q.png)](https://s1.ax1x.com/2018/12/19/FBzh5Q.png)

> 可以看到只有本地和对端路由

下来简单配置rip

```
rip
version 2
network 1.1.1.1
network 192.0.1.0
network 192.0.2.0
```

其他设备配置类似

查看路由表，可以看到已经学习到了邻居的路由信息,
[![img](https://s1.ax1x.com/2018/12/19/FBzj54.png)](https://s1.ax1x.com/2018/12/19/FBzj54.png)

### rip学习原理

**以RT1的loopback0接口1.1.1.1/32（以下称为A)为例子**

1. 当A网络接入rt1中，等待30s的邻居更新时间，将自己的A网络的rip路由信息和其cost值+1以广播的形式扩散出去。
2. RT2,RT3接收到RT1发送的A的路由信息发现自己并没有A的信息，所以将接收到的自己没有的路由信息写入自己的路由表中。
3. rip表中第一列目标地址（此处为A)的地址。
   第二列为下一跳地址（在RT2中，如果想和A网络进行通信，则下一跳地址是RT1的0/1接口的地址）。
   第三列是跳数，RT1广播扩散的是1跳（在RT1中是0跳，广播扩散时需要+1）
4. 同理2.2.2.2和3.3.3.3都被RE1,RT2,RT3互相学习到。如此一来整个拓扑在rip协议的连接下形成了一张互联的网。

### 路由环路产生的过程

[![img](https://s1.ax1x.com/2018/12/19/FBzfUg.png)](https://s1.ax1x.com/2018/12/19/FBzfUg.png)

还是之前的拓扑图；

1. 如果A网络出现故障，直连路由RT1最先收到故障报告，180s没有收到回复信息后删除A的路由信息。并等待30s更新时间后一广播自己路由表的形式通告给网络中其他的rip设备。
2. 30s后在RT1发送自己路由信息的同时其他设备也开始发送自己的路由信息。而RT2的路由信息中依然有A网络的信息;
3. RT1收到RT2的路由表认为RT2中也有一条可以通往A网络的路由，所以RT1又将A网络写进自己的rip路由表下一跳为RT2的g0/2接口的地址，cost值为2；
4. 之后RT3也收到RT2的信息也接收了A网络的路由信息。
   ……

这么一来就形成了环路，直到跳数为16认为网络不可达。

### 环路避免机制

- 路由毒化

当RT1收到A网络的故障信息之后，由原来的删除路由信息变为直接将其跳数置为16（无穷大）路由不可达。

等待30s的更新时间后，RT1将自己的cost=16的路由信息广播 扩散出去。

RT2,RT3收到COST值为无穷大的A网络更新写进自己的rip路由表中，等待老化时间。

-水平分割

水平分割规则如下：路由器不向路径到来的方向回传此路径。当打开路由器接口后，路由器记录路径是从哪个接口来的，并且不向此接口回传此路径。

如上例所说，产生环路的原因是，路由器将从RT1学到的路由信息又发送给了RT1。

按照这样的思路，先设置为，从某一端口学习到的路由信息，不再从这一端口发出。

原来的学习过程现在变为，RT2收到RT1的信息后，RT2发送自己路由信息将不再发送给RT1。

- 毒性逆转

水平分割是路由器用来防止把一个接口得来的路径又从此接口传回导致的问题的方案。水平分割方案忽略在更新过程中从一个路由器获取的路径又传回该路由器。有破坏逆转的水平分割方法是在更新信息中包括这些回传路径，但这种处理方法会把这些回传路径的跳数设为16（无穷）。通过把跳数设为无穷，并把这条路径告诉源路由器，有可能立刻解决路由选择环路。否则，不正确的路径将在路由表中驻留到超时为止。破坏逆转的缺点是它增加了路由更新的的数据大小。

之前的水平分割和路由毒化是被动防御，而毒性逆转是主动将不可达信息发送。

- 保持定时器法

保持定时器法可防止路由器在路径从路由表中删除后一定的时间内（通常为180秒）接受新的路由信息。它的思想是保证每个路由器都收到了路径不可达信息，而且没有路由器发出无效路径信息。在图中，由于路由更新信息被延迟，路由器2向路由器3发出错误信息。但使用保持计数器法后，这种情况将不会发生，因为路由器3将在180秒内不接受通向网络A的新的路径信息，到那时路由器2将存储正确的路由信息。

- 触发更新法

有破坏逆转的水平分割将任何两个路由器构成的环路打破，但三个或更多个路由器构成的环路仍会发生，直到无穷（16）时为止。触发式更新法可加速收敛时间，它的工作原理是当某个路径的跳数改变了，路由器立即发出更新信息，不管路由器是否到达常规信息更新时间都发出更新信息。

## rip路由表策略

通过总结以上的解决方法，rip现在将满足如下情况的路由信息写入自己的路由表中：

> 1. 如果更新的某路由表项在路由表中没有，则直接在路由表中添加该路由表项
> 2. 如果路由表中已有相同目的网络的路由表项，且来源端口相同，那么无条件根据最新的路由信息更新其路由表
> 3. 如果路由表中已有相同目的网络的路由表项，但来源端口不同，则要比较它们的度量值，将度量值较小的一个作为自己的路由表项
> 4. 如果路由表中已有相同目的网络的路由表项，且度量值相等，保留原来的路由表项

## rip报文格式

RIP通过UDP报文进行路由信息的交换，使用的端口号为520。所以它又是一个不可靠的路由协议
由于RIP的实现较为简单，在配置和维护管理方面也远比OSPF和IS-IS容易，因此RIP主要应用于规模较小的网络中，例如校园网以及结构较简单的地区性网络。对于更为复杂的环境和大型网络，一般不使用RIP协议
RIP包括RIP-1和RIP-2两个版本，RIP-2对RIP-1进行了扩充，使其更具有优势

RIP-1报文格式：
[![img](https://s1.ax1x.com/2018/12/17/F03T7F.png)](https://s1.ax1x.com/2018/12/17/F03T7F.png)

| 字段名                           | 长度      | 含义                                                         |
| :------------------------------- | :-------- | :----------------------------------------------------------- |
| Command                          | 8比特     | 标识报文的类型： 1：Request报文，向邻居请求全部或部分路由信息； 2：Reponse报文，发送自己全部或部分路由信息，一个Response报文中最多包含25个路由表项。 |
| Version                          | 8比特     | RIP的版本号：1：RIP-1 2：RIP-2                               |
| Must be zero                     | 16/32比特 | 必须为零字段。                                               |
| AFI（Address family identifier） | 16比特    | 地址族标识，其值为2时表示IP协议。对于Request报文，此字段值为0。 |
| IP Address                       | 32比特    | 该路由的目的IP地址，可以是自然网段的地址，也可以是子网地址或主机地址。 |
| Metric                           | 32比特    | 路由的开销值。对于Request报文，此字段值为16。                |

[![img](https://s1.ax1x.com/2018/12/17/F08Qhj.png)](https://s1.ax1x.com/2018/12/17/F08Qhj.png)

| 字段名                           | 长度   | 含义                                                         |
| :------------------------------- | :----- | :----------------------------------------------------------- |
| Command                          | 8比特  | 标识报文的类型： 1：Request报文，向邻居请求全部或部分路由信息； 2：Reponse报文，发送自己全部或部分路由信息，一个Response报文中最多包含25个路由表项。 |
| Version                          | 8比特  | RIP的版本号：1：RIP-1 2：RIP-2                               |
| Must be zero                     | 16比特 | 必须为零字段。                                               |
| AFI（Address family identifier） | 16比特 | 地址族标识，其值为2时表示IP协议。对于Request报文，此字段值为0。 |
| Route Tag                        | 16比特 | 外部路由标记。                                               |
| IP Address                       | 32比特 | 该路由的目的IP地址，可以是自然网段的地址，也可以是子网地址或主机地址。 |
| Subnet Mask                      | 32比特 | 目的地址的掩码。                                             |
| Next Hop                         | 32比特 | 提供一个更好的下一跳地址。如果为0.0.0.0，则表示发布此路由的路由器地址就是最优下一跳地址。 |
| Metric                           | 32比特 | 路由的开销值。对于Request报文，此字段为16。                  |

RIP-2为了支持报文验证，使用第一个路由表项（Route Entry）作为验证项，并将AFI字段的值设为0xFFFF作为标识。

RIP-2的验证报文格式:

[![img](https://s1.ax1x.com/2018/12/17/F08LVS.png)](https://s1.ax1x.com/2018/12/17/F08LVS.png)

| 字段名              | 长度   | 含义                                                         |
| :------------------ | :----- | :----------------------------------------------------------- |
| Command             | 8比特  | 标识报文的类型： 1：Request报文，向邻居请求全部或部分路由信息； 2：Reponse报文，发送自己全部或部分路由信息，一个Response报文中最多包含25个路由表项。 |
| Version             | 8比特  | RIP的版本号：1：RIP-1 2：RIP-2                               |
| Must be zero        | 16比特 | 必须为零字段。                                               |
| 0xFFFF              | 16比特 | 验证项标识，表示整个路由报文需要验证。                       |
| Authentication Type | 16比特 | 验证类型：2：明文验证； 3：MD5验证。                         |
| Authentication      | 16字节 | 验证口令，当使用明文验证时该字段才会包含密码信息。           |

## rip经典配置（H3C）

[![img](https://s1.ax1x.com/2018/12/19/FBzfUg.png)](https://s1.ax1x.com/2018/12/19/FBzfUg.png)

### 极简配置

RT1:(端口和rip极简配置)

```
int g 0/1 
ip add 192.0.1.1 24
int g 0/2
ip add 192.0.2.1 24
quit
int loopback 0
ip add 1.1.1.1 32

rip

network 1.1.1.1
network 192.0.1.0
network 192.0.2.0
```



RT2:(端口和rip极简配置)

```
int g 0/1 
ip add 192.0.1.2 24
int g 0/2
ip add 192.0.3.1 24
quit
int loopback 0
ip add 2.2.2.2 32

rip

network 2.2.2.2
network 192.0.1.0
network 192.0.3.0
```



RT3:(端口和rip极简配置)

```
int g 0/1 
ip add 192.0.2.2 24
int g 0/2
ip add 192.0.3.2 24
quit
int loopback 0
ip add 3.3.3.3 32

rip

network 3.3.3.3
network 192.0.2.0
network 192.0.3.0
```



### RIPV2掩码配置：

RT1:

```
rip
version 2
undo summary
```

RT2:

```
rip
version 2
undo summary
```

RT3:

```
rip
version 2
undo summary
```

查看rip表（需要等180s的老化时间）
或者重启端口加快rip学习：

```
int g 0/1 
shutdown
undo shutdown
```



[![img](https://s1.ax1x.com/2018/12/19/FDPpFO.png)](https://s1.ax1x.com/2018/12/19/FDPpFO.png)

可以看到已经带掩码了

### 配置RIPV2认证

RT1：

```
rip authentication-mode md5 rfc2453 plain 123456
```

RT2:

```
rip authentication-mode md5 rfc2453 plain 123456
```

RT2:

```
rip authentication-mode md5 rfc2453 plain 123456
```

查看rip表（需要等180s的老化时间）

```
int g 0/1 
shutdown
undo shutdown
```

> 本文不全是笔者原创，有部分是借鉴其他文章，没有表明出处还请谅